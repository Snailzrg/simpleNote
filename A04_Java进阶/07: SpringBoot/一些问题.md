[toc]

## 1.mysql连接errorcode1045

>yml配置文件中：Password 用单引号

## 2 JPA中实体继承属性问题

### 2.1:JPA的继承注解一般有四种

- @MappedSuperclass 这个注解应用的场景是父类不对应任何单独的表，多个子类共用相同的属性
- @Inheritence 此注解应用于根实体类以定义继承策略。 如果没有使用此注释定义策略类型，那么它遵循单表战略。
- @DiscriminatorColumn  鉴别器属性将一个实体与另一个实体区分开来。 因此，该注释用于提供鉴别器列的名称。 仅需要在根实体类上指定此注释。
- @DiscriminatorValue 此注释用于指定表示特定实体的值的类型。 需要在子实体类中指定此注释。

#### 2.1.1 ：这里先说一下一下@MappedSuperclass

 @MappedSuperclass注解使用在父类上面，是用来标识父类的作用

 @MappedSuperclass标识的类表示其不能映射到数据库表，因为其不是一个完整的实体类，但是它所拥有的属性能够映射在其子类对用的数据库表中

 @MappedSuperclass标识得类不能再有@Entity或@Table注解  但是可以使用@Id 和@Column注解



。。。。。。



## 3 JPA数据命名方式

> Spring Data JPA 对数据表默认的命名规则为两个单词之间以下划线分割
>
> 2.1、缺省情况下属性 createTime 会被 JPA 创建为字段 create_time （如果已存在则不再创建）；
> 2.2、驼峰命名法下属性 createTime 会被 JPA 创建为字段 createTime（如果已存在则不再创建）；

我们也可以在 Spring 框架的配置文件 application.ymal 中加入如下配置：
　　**jpa:**
　　 **hibernate:**
　　 **naming:**
　　　　**implicit****-strategy: org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl**
　　  **physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl**

 

## 4 依赖注入的爆红idea

> springboot 项目中 idea 
>
> 关闭：Preferences->Editor->Inspections->Spring->Spring Core->Core->Field Injection warning

依赖注入有三种方式：

| 注入方式          | 形式                                                         |
| ----------------- | :----------------------------------------------------------- |
| 变量（filed）注入 | @Autowired private  <br/> JavaMailSender   javaMailSender;   |
| 构造器注入        | final UserDao userDao;<br/><br/>@Autowired<br/>public UserServiceImpl(UserDao userDao) {<br/>    this.userDao = userDao;<br/>} |
| set方法注入       | private UserDao userDao;<br/><br/>@Autowired<br/>public void setUserDao (UserDao userDao) {<br/>    this.userDao = userDao;<br/>} |


相比较而言：

- 优点：

缺点：不能有效的指明依赖。相信很多人都遇见过一个bug，依赖注入的对象为null，在启动依赖容器时遇到这个问题都是配置的依赖注入少了一个注解什么的，然而这种方式就过于依赖注入容器了，当没有启动整个依赖容器时，这个类就不能运转，在反射时无法提供这个类需要的依赖。
在使用set方式时，这是一种选择注入，可有可无，即使没有注入这个依赖，那么也不会影响整个类的运行。
在使用构造器方式时已经显式注明必须强制注入。通过强制指明依赖注入来保证这个类的运行。

- 另一个方面：

依赖注入的核心思想之一就是被容器管理的类不应该依赖被容器管理的依赖，换成白话来说就是如果这个类使用了依赖注入的类，那么这个类摆脱了这几个依赖必须也能正常运行。然而使用变量注入的方式是不能保证这点的。
既然使用了依赖注入方式，那么就表明这个类不再对这些依赖负责，这些都由容器管理，那么如何清楚的知道这个类需要哪些依赖呢？它就要使用set方法方式注入或者构造器注入。

总结下：
变量方式注入应该尽量避免，使用set方式注入或者构造器注入，这两种方式的选择就要看这个类是强制依赖的话就用构造器方式，选择依赖的话就用set方法注入。





## 5 mybaties中枚举问题





## 6 mybaties 关联查询









## 7 springboot配置文件相关

SpringBoot中有以下两种配置文件bootstrap (.yml 或者 .properties)，application (.yml 或者 .properties)

- 1.加载顺序上的区别

  ```
  bootstrap.yml（bootstrap.properties）先加载
  application.yml（application.properties）后加载
  bootstrap.yml 用于应用程序上下文的引导阶段，由父Spring ApplicationContext加载。父ApplicationContext 被加载到使用application.yml的之前。
  在 Spring Boot 中有两种上下文，一种是 bootstrap, 另外一种是 application, bootstrap 是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何Spring应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。
  ```

- 2.bootstrap/ application 的应用场。

  ```
  bootstrap.yml 和application.yml 都可以用来配置参数。
  bootstrap.yml 可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。
  application 配置文件这个容易理解，pplication.yml 可以用来定义应用级别的，主要用于 Spring Boot 项目的自动化配置。
  
  bootstrap 配置文件有以下几个应用场景。
  使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；
  一些固定的不能被覆盖的属性
  一些加密/解密的场景；
  ```

  















```
return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();
```
