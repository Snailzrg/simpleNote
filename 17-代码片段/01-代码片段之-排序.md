# 归并排序

代码如下
```
package maris.sort;

/**
 * 归并排序
 * @see
 * 把长度为n的输入序列分成两个长度为n/2的子序列；
 * 对这两个子序列分别采用归并排序；
 * 将两个排序好的子序列合并成一个最终的排序序列。
 * 
 * 参考：https://www.cnblogs.com/of-fanruice/p/7678801.html
 */
public class MergeSort {

	public static void sort(int[] arr){
		mergeSort(arr, 0, arr.length-1);
	}
	
	private static void mergeSort(int[] arr, int low, int high){
		int mid = (high + low) / 2;
		if(low < high){
			mergeSort(arr, low, mid);//0,3 -> 0,1 ->0,0
			mergeSort(arr, mid+1, high);//	      ->1,1
			merge(arr, low, mid, high);//		arr,0,0,1
		}
	}
	
	/**
	 * 将 [low,mid] 和 [mid+1,high] 两个有序区间的数据归并
	 */
	private static void merge(int[] arr, int low, int mid, int high){
		int[] temp = new int[high-low+1];
		int i = low;
		int j = mid + 1;
		int k = 0;
		//归并,将较小的数存入新数组,直到某个区间的数存完
		while(i <= mid && j <= high){
			if(arr[i] < arr[j]){
				temp[k++] = arr[i++];
			}else{
				temp[k++] = arr[j++];
			}
		}
		//a.可能左区间剩余，将左区间剩余数据存入数组
		while(i <= mid){
			temp[k++] = arr[i++];
		}
		//b.可能右区间剩余，将右区间剩余数据存入数组
		while(j <= high){
			temp[k++] = arr[j++];
		}
		
		//将已归并的数据，覆盖 原数组对应的区域
		for(int x = 0; x < temp.length; x++){
			arr[x+low] = temp[x];
		}
	}
	
}

```

# 冒泡排序

