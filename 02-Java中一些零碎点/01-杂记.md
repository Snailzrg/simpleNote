## 杂记

一些CSDN博客
- [枚举类型的ordinal()方法](https://blog.csdn.net/lili625/article/details/44651113)
- [slf4j中的MDC](https://www.cnblogs.com/sealedbook/p/6227452.html)- [图片水印](https://www.cnblogs.com/laoyeye/p/7193309.html)
- [扩展点机制](https://my.oschina.net/u/3729778/blog/1575581)
- [微信小程序](https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login)


## 未分类整理
### Java中&0xFF是什么意思
  1：在阅读 LuminanceSource 源码中 发现 源码中ToStrig()使用了为什么要加上“& 0xFF”?
 -  拆分理解下 0xFF是16进制的表达方式，F是15；十进制为：255，二进制为：1111 1111 &运算符：如果2个bit都是1，则得1，否则得0

2: 涉及到 原码、补码和反码相关知识点
- 计算机中，所有数据最终都是使用二进制数表达。 我们也已经学会如何将一个10进制数如何转换为二进制数。 不过，我们仍然没有学习一个负数如何用二进制表达
- 比如，假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为： 00000000 00000000 00000000 00000101 5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0
- 在计算机中，负数以其正值的补码形式表达。 什么叫补码呢？这得从原码，反码说起。

3: 原码、补码、反码
- 原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。 比如 00000000 00000000 00000000 00000101 是 5的 原码。 反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。
- 取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）
- 反码： 比如：将00000000 00000000 00000000 00000101每一位取反，得11111111 11111111 11111111 11111010。 称：11111111 11111111 11111111 11111010 是 00000000 00000000 00000000 00000101 的反码。 反码是相互的，所以也可称： 11111111 11111111 11111111 11111010 和 00000000 00000000 00000000 00000101 互为反码。
- 补码：反码加1称为补码。 也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。 

4: 例子
- 比如：00000000 00000000 00000000 00000101 的反码是：11111111 11111111 11111111 11111010。那么，补码为：11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011 所以，-5 在计算机中表达为：11111111 11111111 11111111 11111011。转换为十六进制：0xFFFFFFFB。
- 再举一例，我们来看整数-1在计算机中如何表示。 假设这也是一个int类型，那么：先取1的原码：00000000 00000000 00000000 00000001 2、得反码： 11111111 11111111 11111111 11111110 3、得补码： 11111111 11111111 11111111 11111111

可见，－1在计算机里用二进制表达就是全1。16进制为：0xFFFFFFFF。 上面这么多蛋疼的操作仅仅是因为：在计算机中，负数以其正值的补码形式表达。 有的人可能会问：那为什么在计算机中，负数以其正值的补码形式表达？
为什么负数以其正值的补码形式表达：说到补码，就不得不引人另一个概念——模数。

5：模数 
- 从物理意义上讲是某种计量器的容量。这里我们经常举的一个例子就是钟表，其模数为12，即每到12就重新从0开始，数学上叫取模或求余(mod)，java、C#和C++里用%表示求余操作。例如： 14%12=2 如果此时的正确时间为6点，而你的手表指向的是8点，如何把表调准呢？有两种方法：一把表逆时针拨两个小时；二是把表顺时针拨10个小时，即 8-2=6 (8+10)%12=6 也就是说在此模数系统里面有 8-2=8+10 这是因为2跟10对模数12互为补数。因此有一下结论：在模数系统中，A-B或A+(-B)等价于A+[B补]，即 8-2/8+(-2)=8+10 我们把10叫做-2在模12下的补码。这样用补码来表示负数就可以将加减法统一成加法来运算，简化了运算的复杂程度。 
- 采用补码进行运算有两个好处，一个就是刚才所说的统一加减法；二就是可以让符号位作为数值直接参加运算，而最后仍然可以得到正确的结果符号，符号位无需再单独处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。

6：回到问题本身 data[1] = (byte)(deY & 0xFF);
- 外部传进来一个参数func，这个参数有可能是负数的，例如传进来一个“-12”，“-12”二进制为： 0000 1100 取反： 1111 0011 补码加1： 1111 0100 byte –> int 就是由8位变 32 位 高24位全部补1： 1111 1111 1111 1111 1111 1111 1111 0100 ; 0xFF的二进制表示就是：1111 1111，高24位补0：0000 0000 0000 0000 0000 0000 1111 1111;
- -12的补码与0xFF 进行与（&）操作 最后就是:0000 0000 0000 0000 0000 0000 1111 0100 最终保持“-12”取反码，补码加1的一致性。 byte类型的数字要&0xff再赋值给int类型，其本质原因就是想保持二进制补码的一致性。 当byte要转化为int的时候，高的24位必然会补1，这样，其二进制补码其实已经不一致了，&0xff可以将高的24位置为0，低8位保持原样。这样做的目的就是为了保证二进制数据的一致性


### JDK8新特性