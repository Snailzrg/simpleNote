## 1.mysql连接errorcode1045

>yml配置文件中：Password 用单引号

## 2 JPA中实体继承属性问题

### 2.1:JPA的继承注解一般有四种

- @MappedSuperclass 这个注解应用的场景是父类不对应任何单独的表，多个子类共用相同的属性
- @Inheritence 此注解应用于根实体类以定义继承策略。 如果没有使用此注释定义策略类型，那么它遵循单表战略。
- @DiscriminatorColumn  鉴别器属性将一个实体与另一个实体区分开来。 因此，该注释用于提供鉴别器列的名称。 仅需要在根实体类上指定此注释。
- @DiscriminatorValue 此注释用于指定表示特定实体的值的类型。 需要在子实体类中指定此注释。

#### 2.1.1 ：这里先说一下一下@MappedSuperclass

 @MappedSuperclass注解使用在父类上面，是用来标识父类的作用

 @MappedSuperclass标识的类表示其不能映射到数据库表，因为其不是一个完整的实体类，但是它所拥有的属性能够映射在其子类对用的数据库表中

 @MappedSuperclass标识得类不能再有@Entity或@Table注解  但是可以使用@Id 和@Column注解



。。。。。。



## 3 JPA数据命名方式

> Spring Data JPA 对数据表默认的命名规则为两个单词之间以下划线分割
>
> 2.1、缺省情况下属性 createTime 会被 JPA 创建为字段 create_time （如果已存在则不再创建）；
> 2.2、驼峰命名法下属性 createTime 会被 JPA 创建为字段 createTime（如果已存在则不再创建）；

我们也可以在 Spring 框架的配置文件 application.ymal 中加入如下配置：
　　**jpa:**
　　 **hibernate:**
　　 **naming:**
　　　　**implicit****-strategy: org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl**
　　  **physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl**

 

## 4 依赖注入的爆红idea

> springboot 项目中 idea 
>
> 关闭：Preferences->Editor->Inspections->Spring->Spring Core->Core->Field Injection warning

依赖注入有三种方式：

| 注入方式          | 形式                                                         |
| ----------------- | :----------------------------------------------------------- |
| 变量（filed）注入 | @Autowired private  <br/> JavaMailSender   javaMailSender;   |
| 构造器注入        | final UserDao userDao;<br/><br/>@Autowired<br/>public UserServiceImpl(UserDao userDao) {<br/>    this.userDao = userDao;<br/>} |
| set方法注入       | private UserDao userDao;<br/><br/>@Autowired<br/>public void setUserDao (UserDao userDao) {<br/>    this.userDao = userDao;<br/>} |


相比较而言：

- 优点：

缺点：不能有效的指明依赖。相信很多人都遇见过一个bug，依赖注入的对象为null，在启动依赖容器时遇到这个问题都是配置的依赖注入少了一个注解什么的，然而这种方式就过于依赖注入容器了，当没有启动整个依赖容器时，这个类就不能运转，在反射时无法提供这个类需要的依赖。
在使用set方式时，这是一种选择注入，可有可无，即使没有注入这个依赖，那么也不会影响整个类的运行。
在使用构造器方式时已经显式注明必须强制注入。通过强制指明依赖注入来保证这个类的运行。

- 另一个方面：

依赖注入的核心思想之一就是被容器管理的类不应该依赖被容器管理的依赖，换成白话来说就是如果这个类使用了依赖注入的类，那么这个类摆脱了这几个依赖必须也能正常运行。然而使用变量注入的方式是不能保证这点的。
既然使用了依赖注入方式，那么就表明这个类不再对这些依赖负责，这些都由容器管理，那么如何清楚的知道这个类需要哪些依赖呢？它就要使用set方法方式注入或者构造器注入。

总结下：
变量方式注入应该尽量避免，使用set方式注入或者构造器注入，这两种方式的选择就要看这个类是强制依赖的话就用构造器方式，选择依赖的话就用set方法注入。





## 5 mybaties中枚举问题





## 6 mybaties 关联查询

