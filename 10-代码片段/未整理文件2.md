```
1：判断一段时间以内生成的数据
	Calendar lastDate = Calendar.getInstance();
	lastDate.roll(Calendar.DATE, -7);// 日期回滚7天
	pastDate = lastDate.getTime();
	// 最近一周的数据
	List<InviterCharts> inviterChartss = inviterChartsDAO.getlastInvitedCharts(pastDate);	
	//大于
	==>return dao.getPOList(InviterCharts.class, null, orders, QueryParamCreator.gt("newDate", lastDate));

2：排序 多规则排序
	Order order1 = new Order(Direction.DESC,"biInvitedNum");
	Order order2 = new Order(Direction.ASC,"newDate");
	orders.add(order1);
	orders.add(order2);	

3： List数据截取
	newList = inviterChartss.subList(0, 100);

4 ：JSONObject	
	JSONObject jo = JSON.parseObject(String result);
	
	Object objId = jo.get("openid");

5 ：StringUtils的使用
   StringUtils.hasText(null) = false
   StringUtils.hasText("") = false
   StringUtils.hasText(" ") = false
   StringUtils.hasText("12345") = true
   StringUtils.hasText(" 12345 ") = true

 String inString = "a6AazAaa77abaa";
 String oldPattern = "aa";
 String newPattern = "foo";
 // Simple replace
 String s = StringUtils.replace(inString, oldPattern, newPattern);
 s.equals("a6AazAfoo77abfoo")=true;

6：ClassLoader 类加载器
   类加载器是负责加载类的对象。ClassLoader 类是一个抽象类。如果给定类的二进制名称，那么类加载器会试图查找或生成构成类定义的数据。一般策略是将名称转换为某个文件名，然后从文件系统读取该名称的“类文件”。 
 
 getResource(String name) 
 查找具有给定名称的资源。

7 Url类
   类 URL 代表一个统一资源定位符，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引擎的查询。 

9 对时间的操作
	DateUtil.parse("2018-9-1" + " 00:00:00", "yyyy-MM-dd HH:mm:ss"),
	DateUtil.parse("2018-9-11" + " 23:59:59", "yyyy-MM-dd HH:mm:ss")));

10 排序
 if (CollectionUtils.isNotEmpty(inviterChartss)) {
				Map<String, Integer> chartNumMap = new LinkedHashMap<String, Integer>();
				for (InviterCharts ic : inviterChartss) {
					int num = 0;
					/*	List<AcceptInvitateUser> aiUsers = ic.getBeInvitedUsers();
					if (CollectionUtils.isNotEmpty(aiUsers)) {
						for (AcceptInvitateUser us : aiUsers) {
							if (us.getDate().compareTo(pastDate) > 0)
								num++;
						}
					}*/
					num=ic.getShowInvitedNum();
					String userName = userDAO.getUserByUserId(ic.getUserId()).getUserName();
					chartNumMap.put(userName, num);
				}
				List<Map.Entry<String, Integer>> infoIds = new ArrayList<Map.Entry<String, Integer>>(
						chartNumMap.entrySet());
				Collections.sort(infoIds, new Comparator<Map.Entry<String, Integer>>() {
					public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {
						return (o2.getValue() - o1.getValue());
					}
				});
				for (int i = 0; i < infoIds.size(); i++) {
					Entry<String, Integer> ent = infoIds.get(i);
					InviterChartsVo vo = new InviterChartsVo();
					vo.setUserName(ent.getKey());
				//	vo.setBiInvitedNum(ent.getValue());
					vo.setShowInvitedNum(ent.getValue());
					inviterChartsVos.add(vo);
					if (i == 9) {// 前十名
						break;
					}

	
11：多开线程处理
	ExecutorService接口




12 ：ReentrantLock
	

13：
```
**文件操相关**

note:Map<String,Integer>  sum= scores.stream().collect(  
	               Collectors.groupingBy(QuestionnarieScoreVo::getOrgName, Collectors.summingInt(QuestionnarieScoreVo::getScore)));  



1：工具类ExcelUtil
//文件上传类
IFileUploadDAO 下面的

a:根据文件id 获取文件的属性
Map<String, Object> attachMap = fileDao.queryFile(fileId);
	if (attachMap.get("fileName") == null || attachMap.get("userId") == null||
	 attachMap.get("fileType") == null || attachMap.get("fileLength") == null|| attachMap.get("uploadDate") == null) {
		continue;
		}
	attachVo.setAttachsId(fileId);
	attachVo.setAttachsName(attachMap.get("fileName").toString());
	attachVo.setUserId(attachMap.get("userId").toString());
	attachVo.setAttachsType(attachMap.get("fileType").toString());
	attachVo.setAttachsLength(Long.valueOf(attachMap.get("fileLength").toString()));
	String date = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(attachMap.get("uploadDate"));
	attachVo.setUploadDate(DateTimeUtil.parse(date));
	listVo.add(attachVo);
  }

b:根据内容 生成Eexecl表单并且....下载
	HSSFWorkbook wb = new HSSFWorkbook();
	String excelName = socialTask.getTaskName() + "服务评价评分结果";	
	String sheetName = "服务评价评分结果";//表单头名称
	HSSFSheet sheet = wb.createSheet(sheetName);

	HSSFCellStyle cellStyle = initExcel(wb, sheetName);//初始化表格
	String[] head = { socialTask.getTaskName() + "统计报表" };
	String fileName = excelName + ".xls";
	//？
	sheet.addMergedRegion(new Region(0, (short) 0, 0, (short) 4));
	// 创建表格头部
	createHead(head, sheet, cellStyle);
	// 写入数据
	wirteQuestionnaireDate(detailVo, wb, questId, sheetName);


//初始化 表格样式
	public HSSFCellStyle initExcel(HSSFWorkbook wb, String name) {

		HSSFSheet sheet = wb.getSheet(name);

		sheet.setDefaultRowHeight((short) 350);
		HSSFFont font = wb.createFont();
		font.setFontName("黑体");
		font.setFontHeightInPoints((short) 12);// 设置字体大小

		HSSFCellStyle cellStyle = wb.createCellStyle();
		cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER); // 居中
		cellStyle.setFont(font);
		return cellStyle;
	}

//创建表头
	public void createHead(String[] head, HSSFSheet sheet, HSSFCellStyle style) {
		if (head != null && head.length > 0) {
			HSSFRow row = sheet.createRow(0);
			for (int i = 0; i < head.length; i++) {
				HSSFRichTextString text = new HSSFRichTextString(head[i]);
				HSSFCell cell = row.createCell((short) i);
				cell.setCellValue(text);
				cell.setCellStyle(style);
			}
		}
	}

//写入数据......


//写入单元格数据
	public void writeCellDate(HSSFRow row, String[] data, HSSFWorkbook wb) {
		if (data != null && data.length > 0) {
			for (int i = 0; i < data.length; i++) {
				HSSFRichTextString text = new HSSFRichTextString(data[i]);
				HSSFCell cell = row.createCell((short) i);
				cell.setCellValue(text);
			}
		}
	}


**java.util.concurrent.locks1 接口 Condition**
	Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set（wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。 
条件（也称为条件队列 或条件变量）为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程（即让其“等待”）。因为访问此共享状态信息发生在不同的线程中，所以它必须受保护，因此要将某种形式的锁与该条件相关联。等待提供一个条件的主要属性是：以原子方式 释放相关的锁，并挂起当前线程，就像 Object.wait 做的那样。 
	Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得 Condition 实例，请使用其 newCondition() 方法。 
作为一个示例，假定有一个绑定的缓冲区，它支持 put 和 take 方法。如果试图在空的缓冲区上执行 take 操作，则在某一个项变得可用之前，线程将一直阻塞；如果试图在满的缓冲区上执行 put 操作，则在有空间变得可用之前，线程将一直阻塞。我们喜欢在单独的等待 set 中保存 put 线程和 take 线程，这样就可以在缓冲区中的项或空间变得可用时利用最佳规划，一次只通知一个线程。可以使用两个 Condition 实例来做到这一点。 

--------------------------------------------------------------------------
~~`任务调度`~~

Scheduler:任务调度器，是实际执行任务调度的控制器。在spring中通过SchedulerFactoryBean封装起来。
Trigger：触发器，用于定义任务调度的时间规则，有SimpleTrigger,CronTrigger,DateIntervalTrigger和NthIncludedDayTrigger，其中CronTrigger用的比较多，本文主要介绍这种方式。CronTrigger在spring中封装在CronTriggerFactoryBean中。
Calendar:它是一些日历特定时间点的集合。一个trigger可以包含多个Calendar，以便排除或包含某些时间点。
JobDetail:用来描述Job实现类及其它相关的静态信息，如Job名字、关联监听器等信息。在spring中有JobDetailFactoryBean和 MethodInvokingJobDetailFactoryBean两种实现，如果任务调度只需要执行某个类的某个方法，就可以通过MethodInvokingJobDetailFactoryBean来调用。
Job：是一个接口，只有一个方法void execute(JobExecutionContext context),开发者实现该接口定义运行任务，JobExecutionContext类提供了调度上下文的各种信息。Job运行时的信息保存在JobDataMap实例中。实现Job接口的任务，默认是无状态的，若要将Job设置成有状态的，
在quartz中是给实现的Job添加@DisallowConcurrentExecution注解（以前是实现StatefulJob接口，现在已被Deprecated）,在与spring结合中可以在spring配置文件的job detail中配置concurrent参数。

调度。。
Scheduler 调度线程主要有两个： 执行常规调度的线程，和执行 misfired trigger 的线程。常规调度线程轮询存储的所有 trigger，如果有需要触发的 trigger，即到达了下一次触发的时间，则从任务执行线程池获取一个空闲线程，执行与该 trigger 关联的任务。Misfire 
线程是扫描所有的 trigger，查看是否有 misfired trigger，如果有的话根据 misfire 的策略分别处理



