[toc]





# 			 [     Linux 安装json神器 jq        ](https://www.cnblogs.com/dongkang/p/11011514.html) 		

```
wget -O jq https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64
chmod +x ./jq
cp jq /usr/bin
```



## 增加swap空间

找一个空间足够的目录用来存放swap文件 

> 　　mkdir /swap 
>  　　cd /swap 
>  　　sudo dd if=/dev/zero of=swapfile bs=1024 count=2000000 
>  　　出现下列提示，上面命令中的 count 即代表swap文件大小。 
>  　　记录了2000000+0 的读入 
>  　　记录了2000000+0 的写出 
>  　　2048000000字节(2.0 GB)已复制，63.3147 秒，32.3 MB/秒 
>  　　把生成的文件转换成 Swap 文件 
>  　　sudo mkswap -f swapfile 
>  　-  mkswap: swapfile：不安全的权限 0644，建议使用 0600。
>         正在设置交换空间版本 1，大小 = 1.9 GiB (2047995904  个字节)
>         无标签， UUID=ae2e2db5-cb73-4b76-a9f1-61741c305909

## 3.激活 Swap 文件

　　sudo swapon swapfile 
 　　再次查看 free -m 的结果。 
 　　total used free shared buffers cached 
 　　Mem: 2012 1971 41 0 572 1156 
 　　-/+ buffers/cache: 241 1770 
 　　Swap: 2209 0 2209 
 　　添加成功。

## 扩展：

　　如果需要卸载这个 swap 文件，可以进入建立的 swap 文件目录。执行下列命令。 
 　　sudo swapoff swapfile 
 　　如果需要一直保持这个 swap ，可以把它写入 /etc/fstab 文件。 
 　　/swap/swapfile /swap swap defaults 0 0



##  跨服务器拷贝文件

> 命令格式： scp -r local_folder remote_username@remote_ip:remote_folder 
>
> scp -r sonarqube-7.3/   root@192.168.0.211:/opt/soft/ 
>
> 将本地文件夹 拷贝到.211 下/opt/soft/下

>从远程复制到本地的scp命令与上面的命令雷同，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。
>
>scp -r root@192.168.225.186:/root/data/redis/redis-4.0.1/    /data/soft/





## 如何快速找出Linux系统中的大文件？

**一、df 和 du 两者区别**

   **df，disk free**， 可以快速获取硬盘被占用了多少空间，目前还剩下多少空间等信息。

   **du，disk usage**，显示磁盘空间的使用情况，统计目录（或文件）所占磁盘空间的大小。

 1、统计的范围不同

 df 是从总体上统计系统各磁盘的占用情况，不能统计具体的文件夹或  文件的大小。

 du 既可以从总体上统计，又可以统计具体的某个文件的大小。

 2、计算方式不同，计算速度不同

 df 通过文件系统来快速获取空间大小的信息，速度快，效率高

 du 通过逐级进入指定目录的每一个子目录，逐个计算每个文件大小并  相加，最终显示出来。

 所以计算速度慢，当文件目录较多文件较大时要等很久很久！！

 而且因为要进入每个子目录计算文件大小，如果当前用户对某些文件  夹没有访问权限时，无法进行计算。

 3、计算结果的差异

 df  可以获取已经删除的文件，由于df是通过文件系统来获取空间大小  的，当我们删除一个文件的时候，这个文件不是马上就在文件系统当 中消失了，而是暂时消失了，当所有程序都不用时，才会根据OS的规 则释放掉已经删除的文件。所以当一个文件刚删除清空没完全释放 时，df 仍会把它计算在内。（当你删除一个大文件前后可以分别用df 命令查看一下，刚删除时还在占用磁盘空间）

 du 只能看到当前存在的、没有被删除的文件。他计算的大小就是当前 他认为存在的所有文件大小的累加和。

 当文件系统也确定删除了该文件后，这时候du与df 的结果就一致了。

 所以在这一点上，可以说df 计算更精确，也可以说df 计算有延迟，根  据个人情况使用就行。

 下面看一下具体如何使用**二、df 和du 的使用**

**1、df -h** (-h参数使结果以K，M，G为单位，提高信息的可读性)

![image-20210120153011257](https://gitee.com/snailzrg/snail_img/raw/master/picgo_snail_img/image-20210518160733551.png)

当目录下文件特别多时，只想显示总文件大小时，用-s非常实用。

**2、du -sh ./\*** (./* 指定当前目录)

在不指定目录的情况下，默认会显示当前目录下的所有子目录的大小。在指定目录的情况下，会分别显示指定目录下的所有文件大小。这一点很实用，可以找到具体哪个文件最大。20210518160712788

![image-20210518160712788](https://gitee.com/snailzrg/snail_img/raw/master/picgo_snail_img/image-20210518160712788.png)





 **三、如何使用df 和 du 双剑合璧找到大文件？**

  **1、首先df -h**

 查看目录下的大文件 然后

**2、du -sh  ./\***

进入占用空间大的目录、或者是自己关注的目录下执行该命





###  虚拟机扩容



![image-20210609223859153](https://gitee.com/snailzrg/snail_img/raw/master/picgo_snail_img/image-20210609223859153.png)

也可以用`lsblk` 命令查看，且显示的更为清晰。显示的磁盘空间大小和 VMware fusion 中设定空间大小一样

##### 磁盘分区

- 使用Linux的fdisk分区工具给磁盘/dev/sda分区，更可以根据提示输入m查看帮助信息，再输入n(表示增加分区)，回车后输入p(创建主分区)，回车后partition number输入4(因为上面已经有两个分区sda1、sda2和sda3)，回车会提示输入分区的start值，end值。都默认即可(即当前能使用的所有空间)，回车后输入W进行保存，分区划分完毕(增加了2G空间)。

![image-20210609224225605](https://gitee.com/snailzrg/snail_img/raw/master/picgo_snail_img/image-20210609224225605.png)

##### 更改新分区类型为 Linux  LVM 类型。

- 可以看到/dev/sda4的Id号为83，我们要将其改成8e(LVM卷文件系统的Id)，具体方法同上跟上一步中的磁盘分区大同小异，输入`fdisk /dev/sda`,选择`t（change a partition's system id 改变一个分区的系统ID）`回车，然后选择分区4回车，然后输入L回车。然后输入8e回车，然后输入w，保存修改的分区信息。最后输入fdisk -l ,查看ID是否修改成功。修改成功后必须重新启动linux系统才能进行后面的操作。

- 现在我们需要重启虚拟机，命令行里提醒，我们需要重启后才能进行下一步操作。

------

##### 格式化新的分区为 ext4格式

- 输入命令 `fdisk -l` 查看磁盘分区情况
- 格式化新的分区为ext4格式。`mkfs.ext4 /dev/sda4`，如下图所示。

![image-20210609231617034](https://gitee.com/snailzrg/snail_img/raw/master/picgo_snail_img/image-20210609231617034.png)

##### 格式化后，创建PV，将物理硬盘分区初始化为物理卷

- 首先用用命令`pvdisplay`查看当前的物理卷。显然并没有`sda4`

- 然后用pvcreate指令用于将物理硬盘分区初始化为物理卷，以便被LVM使用。

- 要创建物理卷必须首先对硬盘进行分区，并且将硬盘分区的类型设置为“8e”后，才能使用pvcreat指令将分区初始化为物理卷。执行命令`pvcreate /dev/sda4`

  ```
  [root@localhost ~]# pvcreate /dev/sda3
  WARNING: ext4 signature detected on /dev/sda3 at offset 1080. Wipe it? [y/n]: y
    Wiping ext4 signature on /dev/sda3.
    Physical volume "/dev/sda3" successfully created.
  ```

- pvcreate /dev/sda4,创建完后，我们可以再用pvdisplay查看到新创建的物理卷。

  ```
  [root@localhost ~]# pvdisplay
    --- Physical volume ---
    PV Name               /dev/sda2
    VG Name               centos
    PV Size               <12.01 GiB / not usable 4.00 MiB
    Allocatable           yes 
    PE Size               4.00 MiB
    Total PE              3073
    Free PE               1
    Allocated PE          3072
    PV UUID               ONh90c-MzC7-DKtq-p0GC-ZGw1-V45w-ER3jdQ
     
    "/dev/sda3" is a new physical volume of "<17.80 GiB"
    --- NEW Physical volume ---
    PV Name               /dev/sda3
    VG Name               
    PV Size               <17.80 GiB
    Allocatable           NO
    PE Size               0   
    Total PE              0
    Free PE               0
    Allocated PE          0
    PV UUID               6qELsz-7cc5-l1F5-ol6w-xVyQ-Q3Rq-BnZOBz
  ```

- 可以看到老的物理卷是有`VG Name` 的，而新的物理卷（也就是`sda 4`），这里是 `centos`, 记住这个，后面要用到。

##### 扩展卷组

- 要扩展VG需要知道当前`lvm`组名，也就是我们上面要记下来的 `VG Name`可以通过命令`vgdisplay`查看。

- 通过命令 `vgextend centos /dev/sda4`动态的扩展卷组，它通过向卷组中添加物理卷来增加卷组的容量。

  ```
  [root@localhost ~]# vgextend centos /dev/sda3
    Volume group "centos" successfully extended
  ```

- 再次执行命令 `vgdisplay`再次查看，容量已经添加进去。

##### 扩容空间到 root 下

- 查看需要扩容的路径，执行命令`fdisk -l`命令，就可以发现，原来lv(root对应lv)的路径是 `/dev/mapper/centos-root`, 那么之后的扩容路径就为`/dev/centos/root`

- 执行命令 `lvextend -L+1.99G /dev/centos/root /dev/sda4`扩展空间到root下，扩容的空间要略小于`VG的free`空间(上图 Free PE / Size     522 / <2.04)，因此这里只输入了1.99G.

  ```
  [root@localhost ~]# lvextend -L+17.7G /dev/centos/root /dev/sda3
    Rounding size to boundary between physical extents: 17.70 GiB.
    Size of logical volume centos/root changed from 10.00 GiB (2560 extents) to 27.70 GiB (7092 extents).
    Logical volume centos/root successfully resized.
  ```

- 然后通过df -h查看，root空间还是没变，因为我们差最后最关键的一步。

##### 扩大未挂载文件系统

- `resize2fs`命令，用于扩大或者缩小未挂载的`ext2,ext3或者是ext4`文件系统。具体命令为：`resize2fs -p /dev/mapper/centos-root 1.99G`。这个路径，就是前面 root 对应 lv 的路径。

  

- 发现报错如下

```tsx
resize2fs: Bad magic number in super-block 当尝试打开 /dev/mapper/centos-root 时
找不到有效的文件系统超级块
```

- 可能我们的系统是xfs 文件系统，执行命令`cat /etc/fstab |grep centos-root`确认下是不是 xfs 文件系统。结果如下

```undefined
/dev/mapper/centos-root /                       xfs     defaults        0 0
```

- xfs 文件系统应该用如下命令扩容

```undefined
xfs_growfs /dev/mapper/centos-root 
```

- 结果如下

```kotlin
meta-data=/dev/mapper/centos-root isize=512    agcount=7, agsize=1113856 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0 spinodes=0
data     =                       bsize=4096   blocks=7588864, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal               bsize=4096   blocks=2560, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
data blocks changed from 7588864 to 8111104
```

- 执行命令`df -h`，根目录的空间已经扩容。如下所示





https://blog.csdn.net/l_liangkk/article/details/81294260
