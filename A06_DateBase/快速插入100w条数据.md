## mysql中 快速插入100w条数据

它是利用mysql中的在**MEMORY引擎**的特点，用于**快速**的插入100w的数据在内存中存放，然后再利用sql插入到目标的表当中。

- 操作步骤

1. **创建表t_user，这是用于存放数据的表。**

```
 1 CREATE TABLE `t_user` (
 2   `id` int(11) NOT NULL AUTO_INCREMENT,
 3   `c_user_id` varchar(36) NOT NULL DEFAULT '',
 4   `c_name` varchar(22) NOT NULL DEFAULT '',
 5   `c_province_id` int(11) NOT NULL,
 6   `c_city_id` int(11) NOT NULL,
 7   `create_time` datetime NOT NULL,
 8   PRIMARY KEY (`id`) ) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4;
```

2.**创建内存表t_user_memory，这是用于快速插入数据的表。**

```
1 CREATE TABLE `t_user_memory` (
2   `id` int(11) NOT NULL AUTO_INCREMENT,
3   `c_user_id` varchar(36) NOT NULL DEFAULT '',
4   `c_name` varchar(22) NOT NULL DEFAULT '',
5   `c_province_id` int(11) NOT NULL,
6   `c_city_id` int(11) NOT NULL,
7   `create_time` datetime NOT NULL,
8   PRIMARY KEY (`id`)
9 ) ENGINE=MEMORY DEFAULT CHARSET=utf8mb4;
```

　3.**创建随机字符串函数randStr()，用于在给c_name赋值时更加随机。**

```
delimiter $$
CREATE DEFINER=`root`@`%` FUNCTION `randStr`(n INT) RETURNS varchar(255) CHARSET utf8mb4
DETERMINISTIC
BEGIN
 DECLARE chars_str varchar(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
 DECLARE return_str varchar(255) DEFAULT '';
 DECLARE i INT DEFAULT 0;
 WHILE i<n DO
     SET return_str = concat(return_str, substring(chars_str, FLOOR(1 + RAND() * 62), 1));
        SET i=i+1;
END WHILE;
RETURN return_str;
END $$
```

   这个函数的语法不用解释也会看得懂，但是还是有几个点需要注意的。

1. **delimiter**关键字，这是一个声明结束符的关键字。简单的来说就是，防止和BEGIN和END之间的语句冲突，因为我们希望这里面的语句是连续执行的。
2. **CONCAT(str,str)**链接两个字符串组成一个新的字符串。
3. **FLOOR(num)**函数，向下取整。例如floor(1.23) = 1 、floor(-1.23) = -2。

 

　　4.**创建随机时间函数randDataTime()，为了后期的时间更加随机。**

```
 ## function 生成时间
create
    definer = root@`%` function randDataTime(sd datetime, ed datetime) returns datetime
BEGIN
    DECLARE
        sub INT DEFAULT 0 ;
    DECLARE
            ret DATETIME ;
        SET sub = ABS(
            UNIX_TIMESTAMP(ed) - UNIX_TIMESTAMP(sd)
        ) ;
        SET ret = DATE_ADD(
            sd,
            INTERVAL FLOOR(1 + RAND() *(sub - 1)) SECOND
        ) ;
    RETURN ret ;
END;
```

里面的需要注意的是DATE_ADD(dateTime,INTERVAL num SECOND)函数，第一个参数是**被添加的时间**，第二个参数是一个组合，表明是添加的长度，如：（INTERVAL 1 YEAR)表示在**原来的基础上添加一年的时间间隔**。

　　5.**创建插入数据存储过程add_t_user_memory (int)**

```
 create
    definer = root@`%` procedure add_t_user_memory(IN n int)
BEGIN
    DECLARE
        i INT DEFAULT 1 ;
    WHILE i < n DO
        INSERT INTO t_user_memory (
            c_user_id,
            c_name,
            c_province_id,
            c_city_id,
            create_time
        )
    VALUES
        (
            uuid(),
            rand_string (20),
            FLOOR(RAND() * 1000),
            RAND() * 100,
            NOW()
        );
SET i = i + 1 ;
END
WHILE ;
END;
```

在完成上面的声明之后我们就可以用CALL add_t_user_memory (1000000)来创建100w的数据啦，这大概需要**20分钟**的时间。但是在调用的过程中却发现了一个问题如下图所示。

![img](https://img2018.cnblogs.com/blog/1626261/201908/1626261-20190811111026401-466330909.png)

原来是't_user_memory' 已经满了。它是我在上面定义的用**内存存放数据**的表，在MYSQL中**默认的大小**是16MB。这个大小只能放4w多条数据，所以我们要想办法把它扩大。那么可以执行下面语句

```
1 SET GLOBAL max_heap_table_size = 1024 * 1024 * 1024 * 1;
2 
3 #查看当前的设置的大小
4 select @@max_heap_table_size;
```

注意：修改需要**重新链接mysql**才能更新修改。这个修改自己机器上玩玩就可以了，在生产环境这么改有什么后果我可不负责。

- **完善数据库**

1. 执行下面语句，大概需要10s就可以插入到t_user中。

```
INSERT INTO t_user SELECT * FROM t_user_memory;
```

　　2.打乱创建时间。

```
#更新年间隔
UPDATE t_user SET create_time=date_add(create_time, interval FLOOR(1 + (RAND() * 4)) year);
#更新秒间隔
UPDATE t_user SET create_time=randDataTime(NOW(),create_time);
```

- **完成**

这样，我们的百万级数据库就创建完成啦！然后，我们可以**将t_user_memory这个表清空**，毕竟它是很占内存的，你数据有多少内存就占多少。下次再结合业务试试SQL优化怎么玩。





```
select * from information_schema.tables where table_name='t_user_memory';
```



大约16M, 另一个有用的信息是这个表的存储引擎是 MEMORY.

这个是由于 create table test like information_schema.tables, create table test1 like test; 而information_schema.tables是tables表是memory存储引擎所致。

而 memory 的大小受到 'max_heap_table_size' 参数影响

mysql> show variables like 'max_heap_table_size';

